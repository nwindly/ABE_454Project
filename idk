import json
import boto3
import os
import jwt
import datetime
import uuid
from decimal import Decimal

# --- Configuration (Environment Variables) ---
JWT_SECRET = os.environ.get("JWT_SECRET")
REGION_NAME = os.environ.get("AWS_REGION", "us-east-1")
CONNECTIONS_TABLE_NAME = os.environ.get("CONNECTIONS_TABLE_NAME") 
DYNAMODB_TABLE_NAME = os.environ.get("DYNAMODB_TABLE_NAME")
GROUPS_TABLE_NAME = os.environ.get("GROUPS_TABLE_NAME")
API_GATEWAY_ENDPOINT = os.environ.get("API_GATEWAY_ENDPOINT") 

# --- AWS Clients ---
dynamodb = boto3.resource("dynamodb", region_name=REGION_NAME)
connections_table = dynamodb.Table(CONNECTIONS_TABLE_NAME)
table = dynamodb.Table(DYNAMODB_TABLE_NAME)
groups_table = dynamodb.Table(GROUPS_TABLE_NAME)
apigw_management = boto3.client("apigatewaymanagementapi", endpoint_url=API_GATEWAY_ENDPOINT)

# --- Helper Functions (reusing from your code) ---
def verify_jwt(token):
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        print("Token has expired.")
        return None
    except jwt.InvalidSignatureError:
        print("Invalid token signature.")
        return None
    except jwt.InvalidTokenError as e:
        print(f"Invalid token: {e}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return None

def get_user_attributes_from_connection(event):
    try:
        headers = event.get('headers')
        if not headers:
            return None
        auth_header = headers.get('Authorization') or headers.get('authorization')
        if not auth_header:
            return None

        if auth_header.startswith('Bearer '):
            token = auth_header[7:]
        else:
            token = auth_header

        user_data = verify_jwt(token)
        return user_data
    except Exception as e:
        print(f"Error extracting attributes from connection: {e}")
        return None

def get_username_from_connection_id(connection_id):
    try:
        response = connections_table.get_item(Key={'connectionId': connection_id})
        item = response.get('Item')
        return item.get('username') if item else None
    except Exception as e:
        print(f"Error getting username from connection ID: {e}")
        return None

def get_group_members(group_id):
    try:
        response = groups_table.get_item(Key={'groupID': group_id})
        item = response.get('Item')
        return item.get('members') if item else None
    except Exception as e:
        print(f"Error getting group members: {e}")
        return

def get_connection_ids_for_users(usernames):
    connection_ids = {}
    try:
        response = connections_table.scan(
            FilterExpression='username IN (:usernames)',
            ExpressionAttributeValues={':usernames': usernames}
        )
        items = response.get('Items',)
        for item in items:
            connection_ids[item['username']] = item['connectionId']
    except Exception as e:
        print(f"Error getting connection IDs for users: {e}")
    return connection_ids

# --- Route Handlers ---

def connect_handler(event, context):
    connection_id = event.get('requestContext', {}).get('connectionId')
    user_data = get_user_attributes_from_connection(event)

    if not connection_id:
        print("Error: connectionId not found in event.")
        return {'statusCode': 500, 'body': 'Failed to retrieve connection ID.'}

    if not user_data:
        print("Error: Unauthorized - Invalid or missing token during connect.")
        return {'statusCode': 401, 'body': 'Unauthorized: Invalid or missing token.'}

    username = user_data.get('username')
    if not username:
        print("Error: Username not found in JWT payload.")
        return {'statusCode': 400, 'body': 'Error: Username not found in JWT.'}

    try:
        user_groups_response = groups_table.scan(
            FilterExpression='contains(members, :username)',
            ExpressionAttributeValues={':username': username}
        )
        member_group_ids = [item['groupID'] for item in user_groups_response.get('Items',)]

        connections_table.put_item(
            Item={
                'connectionId': connection_id,
                'username': username,
                'memberGroupIds': member_group_ids
            }
        )
        print(f"Connection established for user: {username} in groups {member_group_ids} with connection ID: {connection_id}")
        return {'statusCode': 200, 'body': 'Connected.'}
    except Exception as e:
        print(f"Error storing connection information: {e}")
        return {'statusCode': 500, 'body': f'Failed to store connection information: {str(e)}'}

def disconnect_handler(event, context):
    connection_id = event.get('requestContext', {}).get('connectionId')

    if not connection_id:
        print("Error: connectionId not found in event during disconnect.")
        return {'statusCode': 500, 'body': 'Failed to retrieve connection ID.'}

    try:
        connections_table.delete_item(
            Key={'connectionId': connection_id}
        )
        print(f"Connection closed for connection ID: {connection_id}")
        return {'statusCode': 200, 'body': 'Disconnected.'}
    except Exception as e:
        print(f"Error removing connection information: {e}")
        return {'statusCode': 500, 'body': f'Failed to remove connection information: {str(e)}'}

def message_handler(event, context):
    connection_id = event.get('requestContext', {}).get('connectionId')
    username = get_username_from_connection_id(connection_id)

    if not username:
        print("Error: Could not retrieve username for connection ID.")
        return {'statusCode': 400, 'body': 'Error: Could not retrieve username.'}

    try:
        body = json.loads(event['body'])
        group_id = body.get('groupId')
        message_text = body.get('messageText')

        if not group_id or not message_text:
            print("Error: groupId and messageText are required in the message body.")
            return {'statusCode': 400, 'body': 'Error: groupId and messageText are required.'}

        user_groups_response = groups_table.scan(
            FilterExpression='contains(members, :username) AND groupID = :group_id',
            ExpressionAttributeValues={':username': username, ':group_id': group_id}
        )
        user_is_member = user_groups_response.get('Items')

        if not user_is_member:
            print(f"Error: User {username} is not a member of group {group_id}.")
            return {'statusCode': 403, 'body': 'Unauthorized: User is not a member of this group.'}

        message_id = str(uuid.uuid4())
        timestamp = int(datetime.datetime.now().timestamp())

        item = {
            'messageId': message_id,
            'senderUsername': username,
            'groupId': group_id,
            'messageText': message_text,
            'timestamp': timestamp,
        }
        table.put_item(Item=item)
        print(f"Message stored in DynamoDB: {message_id}")

        response = connections_table.scan(
            FilterExpression='contains(memberGroupIds, :group_id)',
            ExpressionAttributeValues={':group_id': group_id}
        )
        connections = response.get('Items',)

        payload = json.dumps({
            'groupId': group_id,
            'senderUsername': username,
            'messageText': message_text,
            'timestamp': timestamp
        })

        for connection in connections:
            member_connection_id = connection['connectionId']
            try:
                apigw_management.post_to_connection(
                    ConnectionId=member_connection_id,
                    Data=payload.encode('utf-8')
                )
                print(f"Message sent to connection ID: {member_connection_id} (user: {connection['username']})")
            except Exception as e:
                print(f"Error sending message to connection ID {member_connection_id}: {e}")

        return {'statusCode': 200, 'body': 'Message sent successfully.'}

    except Exception as e:
        print(f"Error handling message: {e}")
        return {'statusCode': 500, 'body': f'Internal Server Error: {str(e)}'}

# --- Main Lambda Handler (Router) ---

def lambda_handler(event, context):
    route_key = event.get('requestContext', {}).get('routeKey')

    if route_key == '$connect':
        return connect_handler(event, context)
    elif route_key == '$disconnect':
        return disconnect_handler(event, context)
    elif route_key == 'sendmessage':
        return message_handler(event, context)
    else:
        print(f"Unhandled route key: {route_key}")
        return {'statusCode': 404, 'body': f'Unhandled route key: {route_key}'}